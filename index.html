<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Text-to-Circuit Pattern Encoder</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: #0d0d1a;
    color: #e0e0e0;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 2rem 1rem;
  }

  h1 {
    font-size: 1.6rem;
    font-weight: 300;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: #8888cc;
    margin-bottom: 1.5rem;
  }

  .container {
    width: 100%;
    max-width: 1000px;
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
  }

  .panel {
    background: #14142a;
    border: 1px solid #2a2a4a;
    border-radius: 12px;
    padding: 1.5rem;
  }

  .panel-label {
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    color: #6666aa;
    margin-bottom: 0.75rem;
  }

  textarea {
    width: 100%;
    background: #0d0d1a;
    border: 1px solid #2a2a4a;
    border-radius: 8px;
    color: #e0e0e0;
    font-family: 'Consolas', 'Courier New', monospace;
    font-size: 1rem;
    padding: 0.75rem 1rem;
    resize: vertical;
    min-height: 60px;
    outline: none;
    transition: border-color 0.2s;
  }
  textarea:focus { border-color: #6666aa; }

  .info-row {
    display: flex;
    gap: 1.5rem;
    margin-top: 0.5rem;
    font-size: 0.78rem;
    color: #7777aa;
  }
  .info-row span { white-space: nowrap; }

  .btn-row {
    display: flex;
    gap: 0.75rem;
    margin-top: 1rem;
    flex-wrap: wrap;
  }

  button {
    background: #2a2a5a;
    border: 1px solid #3a3a6a;
    color: #ccccee;
    padding: 0.5rem 1.2rem;
    border-radius: 6px;
    font-size: 0.85rem;
    cursor: pointer;
    transition: background 0.15s, border-color 0.15s;
  }
  button:hover { background: #3a3a6a; border-color: #5555aa; }
  button:active { background: #4a4a7a; }
  button.primary { background: #4444aa; border-color: #5555cc; }
  button.primary:hover { background: #5555bb; }

  .preview-area {
    background: #1a1a2e;
    border-radius: 8px;
    min-height: 120px;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: auto;
    padding: 1.5rem;
  }
  .preview-area svg { max-width: 100%; height: auto; }
  .preview-placeholder {
    color: #3a3a5a;
    font-size: 0.9rem;
    font-style: italic;
  }

  .variants-grid {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    width: 100%;
  }
  .variant-item {
    position: relative;
    background: #1a1a2e;
    border: 2px solid transparent;
    border-radius: 8px;
    padding: 1rem;
    cursor: pointer;
    transition: border-color 0.2s, background 0.15s;
  }
  .variant-item:hover { border-color: #3a3a6a; }
  .variant-item.selected { border-color: #6666cc; background: #1a1a36; }
  .variant-label {
    position: absolute;
    top: 0.5rem;
    left: 0.75rem;
    font-size: 0.65rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: #5555aa;
    font-weight: 600;
  }
  .variant-item.selected .variant-label { color: #8888dd; }
  .variant-item svg { max-width: 100%; height: auto; display: block; }

  .decode-area {
    display: flex;
    gap: 0.75rem;
    align-items: stretch;
  }
  .decode-area textarea { flex: 1; min-height: 80px; font-size: 0.8rem; }

  .decoded-output {
    margin-top: 0.75rem;
    padding: 0.6rem 1rem;
    background: #0d0d1a;
    border-radius: 6px;
    font-family: 'Consolas', monospace;
    font-size: 0.95rem;
    color: #88cc88;
    min-height: 2rem;
    word-break: break-all;
  }
  .decoded-output.error { color: #cc6666; }

  .drop-zone {
    border: 2px dashed #2a2a4a;
    border-radius: 8px;
    padding: 1rem;
    text-align: center;
    color: #4a4a6a;
    font-size: 0.8rem;
    cursor: pointer;
    transition: border-color 0.2s, color 0.2s;
    min-width: 140px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 0.3rem;
  }
  .drop-zone:hover, .drop-zone.dragover {
    border-color: #6666aa;
    color: #8888cc;
  }
  .drop-zone input { display: none; }

  .toast {
    position: fixed;
    bottom: 2rem;
    left: 50%;
    transform: translateX(-50%) translateY(100px);
    background: #3a3a6a;
    color: #e0e0e0;
    padding: 0.6rem 1.4rem;
    border-radius: 8px;
    font-size: 0.85rem;
    opacity: 0;
    transition: transform 0.3s, opacity 0.3s;
    pointer-events: none;
    z-index: 100;
  }
  .toast.show {
    transform: translateX(-50%) translateY(0);
    opacity: 1;
  }

  .header-row {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-bottom: 1.5rem;
  }
  .header-row h1 { margin-bottom: 0; }

  .btn-doc {
    background: transparent;
    border: 1px solid #3a3a6a;
    color: #8888cc;
    padding: 0.35rem 0.9rem;
    border-radius: 6px;
    font-size: 0.75rem;
    letter-spacing: 0.06em;
    cursor: pointer;
    transition: background 0.15s, border-color 0.15s;
  }
  .btn-doc:hover { background: #2a2a5a; border-color: #5555aa; }

  .modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.75);
    z-index: 200;
    display: none;
    align-items: center;
    justify-content: center;
    padding: 2rem;
  }
  .modal-overlay.open { display: flex; }

  .modal {
    background: #14142a;
    border: 1px solid #2a2a4a;
    border-radius: 12px;
    max-width: 780px;
    width: 100%;
    max-height: 85vh;
    overflow-y: auto;
    padding: 2rem 2.5rem;
    position: relative;
  }
  .modal::-webkit-scrollbar { width: 6px; }
  .modal::-webkit-scrollbar-track { background: transparent; }
  .modal::-webkit-scrollbar-thumb { background: #2a2a4a; border-radius: 3px; }

  .modal-close {
    position: sticky;
    top: 0;
    float: right;
    background: #2a2a5a;
    border: 1px solid #3a3a6a;
    color: #ccccee;
    width: 2rem;
    height: 2rem;
    border-radius: 6px;
    font-size: 1.1rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1;
  }
  .modal-close:hover { background: #3a3a6a; }

  .doc h2 {
    font-size: 1.2rem;
    font-weight: 400;
    color: #8888cc;
    margin: 0 0 1.2rem 0;
    letter-spacing: 0.08em;
  }
  .doc h3 {
    font-size: 0.95rem;
    font-weight: 600;
    color: #aaaadd;
    margin: 1.5rem 0 0.6rem 0;
  }
  .doc p {
    font-size: 0.85rem;
    line-height: 1.65;
    color: #c0c0d8;
    margin: 0 0 0.8rem 0;
  }
  .doc code {
    background: #0d0d1a;
    padding: 0.15rem 0.4rem;
    border-radius: 4px;
    font-size: 0.8rem;
    color: #88cc88;
    font-family: 'Consolas', 'Courier New', monospace;
  }
  .doc pre {
    background: #0d0d1a;
    border: 1px solid #2a2a4a;
    border-radius: 6px;
    padding: 0.8rem 1rem;
    font-size: 0.78rem;
    line-height: 1.5;
    color: #88cc88;
    overflow-x: auto;
    margin: 0.5rem 0 1rem 0;
    font-family: 'Consolas', 'Courier New', monospace;
  }
  .doc ul {
    margin: 0 0 0.8rem 1.2rem;
    font-size: 0.85rem;
    line-height: 1.65;
    color: #c0c0d8;
  }
  .doc .diagram {
    text-align: center;
    padding: 1rem 0;
  }
  .doc .diagram svg { max-width: 100%; height: auto; }
  .doc .step-num {
    display: inline-block;
    background: #4444aa;
    color: #fff;
    width: 1.5rem;
    height: 1.5rem;
    border-radius: 50%;
    text-align: center;
    line-height: 1.5rem;
    font-size: 0.75rem;
    font-weight: 700;
    margin-right: 0.5rem;
  }
  .doc hr {
    border: none;
    border-top: 1px solid #2a2a4a;
    margin: 1.5rem 0;
  }
</style>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
  }
}
</script>
</head>
<body>

<div class="header-row">
  <h1>Circuit Pattern Encoder</h1>
  <button class="btn-doc" id="btnDocs">Documentation</button>
</div>

<!-- Documentation Modal -->
<div class="modal-overlay" id="docModal">
  <div class="modal">
    <button class="modal-close" id="docClose">&times;</button>
    <div class="doc">
      <h2>How It Works</h2>

      <p>This tool encodes plain text into circuit-board-style SVG patterns that look like abstract maze art. The patterns are fully <strong>decodable</strong> &mdash; the same input always produces the same pattern, and the original text can be recovered from the SVGs.</p>

      <h3><span class="step-num">1</span>The Grid</h3>
      <p>Each pattern lives on a <code>17 &times; 5</code> grid of nodes (85 total). Between adjacent nodes, edges can be drawn &mdash; horizontal, vertical, diagonal lines, or quarter-circle arcs. The grid dimensions and spacing were derived from reference SVG designs:</p>
      <pre>Node position:  x = 30.87 + col &times; 111.14
                y = 30.87 + row &times; 111.14
ViewBox:        1840 &times; 507 px
Stroke width:   61.745 px (round caps)</pre>

      <h3><span class="step-num">2</span>Character Encoding (6-bit)</h3>
      <p>Each character is mapped to a 6-bit code supporting 44 characters:</p>
      <pre>A-Z  &rarr;  0-25
0-9  &rarr;  26-35
SPACE &rarr; 36    .  &rarr; 37    ,  &rarr; 38    -  &rarr; 39
!    &rarr;  40    ?  &rarr; 41    '  &rarr; 42    :  &rarr; 43</pre>

      <h3><span class="step-num">3</span>Bit Stream Layout</h3>
      <p>Each panel (17&times;5 grid) carries <strong>148 data bits</strong> &mdash; 80 horizontal edge slots + 68 vertical edge slots. The bit stream is packed as:</p>
      <pre>[5 bits: character count (0-23)]
[3 bits: XOR checksum]
[6 bits &times; N: character codes]
[zero-padded to 148 bits]</pre>
      <p>This gives a maximum of <strong>23 characters per panel</strong>. Longer text spans multiple panels stacked vertically.</p>

      <h3><span class="step-num">4</span>Stride Permutation</h3>
      <p>To spread data bits evenly across the grid (instead of clustering at the top-left), bits are mapped to edge positions using a <strong>stride-based permutation</strong>:</p>
      <pre>edge_index = (bit_position &times; 119) mod 148</pre>
      <p>The stride 119 is coprime to 148, creating a bijection that distributes bits across all grid regions evenly.</p>

      <h3><span class="step-num">5</span>Aesthetic Enhancement</h3>
      <p>After data edges are placed, decorative elements are added to create the circuit-board look. These are <strong>not data-carrying</strong> and are ignored during decoding:</p>
      <ul>
        <li><strong>L-Corner Arcs</strong> &mdash; quarter-circle curves at right-angle turns in the data paths, matching the reference style</li>
        <li><strong>Fill Diagonals</strong> &mdash; straight lines or arcs in sparse regions (~5% of cells)</li>
      </ul>
      <p>Constraints prevent visual artifacts: no cycles (tracked via Union-Find), max 4 edges per node, and no tight triangles from straight-line diagonals.</p>

      <h3><span class="step-num">6</span>3-Variant Security</h3>
      <p>Each encoding produces <strong>3 distinct visual variants</strong>. Empty bit positions (data = 0) are filled with variant-dependent random noise using a 3-bit pattern scheme:</p>
      <ul>
        <li>Data edges (bit = 1) appear in <strong>all 3 variants</strong></li>
        <li>Noise edges appear in <strong>at most 2 of 3 variants</strong> (patterns 001&ndash;110, never 111)</li>
        <li>Decoding: AND-intersect all 3 variants &rarr; only true data survives</li>
      </ul>
      <p>This makes individual variants visually dense (~44% coverage matching references) while requiring all 3 SVGs to recover the text. A single variant cannot be decoded alone.</p>

      <h3><span class="step-num">7</span>SVG Rendering</h3>
      <p>Edges are chained into polylines (starting from degree-1 endpoints) and rendered as SVG <code>&lt;path&gt;</code> elements. Horizontal edges become <code>H</code> commands, vertical become <code>V</code>, diagonals become <code>L</code>, and arcs use cubic bezier <code>C</code> curves with the standard quarter-circle factor K = 0.5523.</p>

      <h3><span class="step-num">8</span>Decoding</h3>
      <p>To decode, all 3 variant SVGs are required. The decoder:</p>
      <ul>
        <li>Parses each SVG's <code>&lt;path&gt;</code> elements</li>
        <li>Snaps coordinates to the nearest grid node</li>
        <li>Extracts H/V edges (ignores diagonals and arcs)</li>
        <li>AND-intersects the 3 grids to recover data bits</li>
        <li>Reverses the stride permutation</li>
        <li>Reads the header, character codes, and verifies the checksum</li>
      </ul>

      <hr>

      <h3>Adaptive Fill</h3>
      <p>Random noise fill is <strong>quadrant-balanced</strong> (4 columns &times; 2 rows = 8 zones). Sparse zones receive more fill to maintain even visual density. A target of ~58 total visual edges per panel ensures short inputs (like "A") still produce dense patterns.</p>

      <h3>Determinism</h3>
      <p>All random decisions use a deterministic hash function seeded with grid position, character data, and variant index. Same input always produces the exact same 3 patterns.</p>

      <h3>Architecture</h3>
      <p>Five classes power everything, all in a single HTML file:</p>
      <pre>CircuitGrid    &mdash; Edge storage, bit serialization
TextEncoder_   &mdash; Text &rarr; bit stream &rarr; grid edges
AestheticSolver &mdash; Decorative arcs and diagonals
SVGRenderer    &mdash; Grid &rarr; SVG path strings
PatternDecoder &mdash; SVG &rarr; grid &rarr; text</pre>
    </div>
  </div>
</div>

<div class="container">
  <!-- Encode Section -->
  <div class="panel">
    <div class="panel-label">Encode Text</div>
    <textarea id="inputText" placeholder="Type text to encode (A-Z, 0-9, space, . , - ! ? ' :)" spellcheck="false"></textarea>
    <div class="info-row">
      <span id="charCount">0 / 23 characters</span>
      <span id="panelCount">1 panel</span>
      <span id="bitInfo">0 / 148 bits used</span>
    </div>
    <div class="btn-row">
      <button class="primary" id="btnEncode">Encode</button>
      <button id="btnDownload" disabled>Download SVG</button>
      <button id="btnDownloadAll" disabled>Download All (.zip)</button>
      <button id="btnCopy" disabled>Copy SVG</button>
      <button id="btnShare" disabled>Share Link</button>
    </div>
  </div>

  <!-- Preview -->
  <div class="panel">
    <div class="panel-label">Preview — 3 Variants (click to select)</div>
    <div class="preview-area" id="previewArea">
      <span class="preview-placeholder">Enter text and click Encode</span>
    </div>
  </div>

  <!-- 3D Model Preview -->
  <div class="panel" id="model3DPanel" style="display: none;">
    <div class="panel-label">3D Model Preview — 3 Variants</div>
    <div style="display: flex; flex-direction: column; gap: 0.75rem;">
      <div class="model3d-slot" style="position: relative; background: #0d0d1a; border-radius: 8px; height: 300px;">
        <span class="model3d-label" style="position: absolute; top: 0.5rem; left: 0.75rem; font-size: 0.65rem; text-transform: uppercase; letter-spacing: 0.1em; color: #5555aa; font-weight: 600; z-index: 1;">Variant 1</span>
        <canvas class="model3d-canvas" style="width: 100%; height: 100%; display: block;"></canvas>
        <span class="model3d-loading" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #6666aa; font-size: 0.9rem;">Loading...</span>
      </div>
      <div class="model3d-slot" style="position: relative; background: #0d0d1a; border-radius: 8px; height: 300px;">
        <span class="model3d-label" style="position: absolute; top: 0.5rem; left: 0.75rem; font-size: 0.65rem; text-transform: uppercase; letter-spacing: 0.1em; color: #5555aa; font-weight: 600; z-index: 1;">Variant 2</span>
        <canvas class="model3d-canvas" style="width: 100%; height: 100%; display: block;"></canvas>
        <span class="model3d-loading" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #6666aa; font-size: 0.9rem;">Loading...</span>
      </div>
      <div class="model3d-slot" style="position: relative; background: #0d0d1a; border-radius: 8px; height: 300px;">
        <span class="model3d-label" style="position: absolute; top: 0.5rem; left: 0.75rem; font-size: 0.65rem; text-transform: uppercase; letter-spacing: 0.1em; color: #5555aa; font-weight: 600; z-index: 1;">Variant 3</span>
        <canvas class="model3d-canvas" style="width: 100%; height: 100%; display: block;"></canvas>
        <span class="model3d-loading" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #6666aa; font-size: 0.9rem;">Loading...</span>
      </div>
    </div>
    <div style="display: flex; align-items: center; gap: 1rem; margin-top: 0.75rem;">
      <button id="btnDownloadSTL" class="primary">Download All STL</button>
      <span id="model3DDims" style="font-size: 0.78rem; color: #7777aa;"></span>
    </div>
  </div>

  <!-- Decode Section -->
  <div class="panel">
    <div class="panel-label">Decode Pattern (drop or select all 3 variant SVGs)</div>
    <div class="decode-area">
      <textarea id="svgInput" placeholder="Paste all 3 SVG variants here (separated by blank lines) to decode..."></textarea>
      <div class="drop-zone" id="dropZone">
        <span>Drop 3 SVGs</span>
        <span>or click</span>
        <input type="file" id="fileInput" accept=".svg" multiple>
      </div>
    </div>
    <div class="btn-row">
      <button id="btnDecode">Decode (3 variants)</button>
    </div>
    <div class="decoded-output" id="decodedOutput"></div>
  </div>

  <!-- Self-test Results -->
  <div class="panel" id="testPanel">
    <div class="panel-label">Self-Test Results</div>
    <div id="testResults" style="font-family: 'Consolas', monospace; font-size: 0.82rem; line-height: 1.6;"></div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script>
// ─── Constants ───────────────────────────────────────────────────────
const COLS = 17;
const ROWS = 5;
const CELL = 111.141;
const PAD  = 30.8725;
const SW   = 61.745;
const VB_W = 1840;
const VB_H = 507;
const MAX_CHAIN = 999; // unlimited chaining for smooth connections
const PANEL_GAP = 60;
const K    = 0.5523;  // cubic bezier quarter-circle factor

const H_EDGE_COUNT = 80;  // 5 rows × 16 gaps
const V_EDGE_COUNT = 68;  // 17 cols × 4 gaps
const TOTAL_BITS   = H_EDGE_COUNT + V_EDGE_COUNT; // 148

const HEADER_LEN_BITS = 5;
const HEADER_CHK_BITS = 3;
const HEADER_BITS     = HEADER_LEN_BITS + HEADER_CHK_BITS; // 8
const CHAR_BITS       = 6;
const MAX_CHARS       = Math.floor((TOTAL_BITS - HEADER_BITS) / CHAR_BITS); // 23

const CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 .,-!?\':';

function nodeX(c) { return PAD + c * CELL; }
function nodeY(r) { return PAD + r * CELL; }

// ─── CircuitGrid ─────────────────────────────────────────────────────
class CircuitGrid {
  constructor() {
    // hEdges[row][col] — row: 0..4, col: 0..15
    this.hEdges = Array.from({length: ROWS}, () => new Uint8Array(COLS - 1));
    // vEdges[row][col] — row: 0..3, col: 0..16
    this.vEdges = Array.from({length: ROWS - 1}, () => new Uint8Array(COLS));
    // dEdges: diagonal edges for aesthetics (fill diags only)
    // Each entry: { r1, c1, r2, c2, type: 'arc'|'line' }
    this.dEdges = [];
    // smoothCorners: bend nodes where H→V corners are rendered as smooth bezier curves.
    // Map from "r,c" → {r1, c1, r2, c2} (the two arc endpoints, H-connected first)
    this.smoothCorners = new Map();
  }

  setH(row, col, val) { this.hEdges[row][col] = val ? 1 : 0; }
  setV(row, col, val) { this.vEdges[row][col] = val ? 1 : 0; }
  getH(row, col) { return this.hEdges[row][col]; }
  getV(row, col) { return this.vEdges[row][col]; }

  addDiag(r1, c1, r2, c2, type) {
    this.dEdges.push({ r1, c1, r2, c2, type });
  }

  // Get degree of node (r, c) counting only H and V edges
  getNodeDegreeHV(r, c) {
    let d = 0;
    // left
    if (c > 0 && this.hEdges[r][c - 1]) d++;
    // right
    if (c < COLS - 1 && this.hEdges[r][c]) d++;
    // up
    if (r > 0 && this.vEdges[r - 1][c]) d++;
    // down
    if (r < ROWS - 1 && this.vEdges[r][c]) d++;
    return d;
  }

  // Get full degree including diagonals
  getNodeDegree(r, c) {
    let d = this.getNodeDegreeHV(r, c);
    for (const e of this.dEdges) {
      if ((e.r1 === r && e.c1 === c) || (e.r2 === r && e.c2 === c)) d++;
    }
    return d;
  }

  // Build the canonical bit-index-to-edge mapping (column-spread interleaved)
  // Uses a stride coprime to 148 to spread bits evenly across all rows/columns
  static _buildBitMap() {
    if (CircuitGrid._bitMap) return CircuitGrid._bitMap;
    // Build natural row-band order
    const natural = [];
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS - 1; c++)
        natural.push({ type: 'H', r, c });
      if (r < ROWS - 1)
        for (let c = 0; c < COLS; c++)
          natural.push({ type: 'V', r, c });
    }
    // Stride permutation: coprime to 148 ensures every slot is hit exactly once
    const N = natural.length; // 148
    const STRIDE = 119; // optimal for even quadrant distribution
    const map = new Array(N);
    for (let i = 0; i < N; i++) {
      map[i] = natural[(i * STRIDE) % N];
    }
    CircuitGrid._bitMap = map;
    return map;
  }

  // Convert H and V edges to a flat bit array (148 bits) in canonical order
  toBitArray() {
    const map = CircuitGrid._buildBitMap();
    const bits = [];
    for (const entry of map) {
      if (entry.type === 'H') bits.push(this.hEdges[entry.r][entry.c]);
      else bits.push(this.vEdges[entry.r][entry.c]);
    }
    return bits;
  }

  // Set H and V edges from a flat bit array
  fromBitArray(bits) {
    const map = CircuitGrid._buildBitMap();
    for (let i = 0; i < map.length; i++) {
      const entry = map[i];
      if (entry.type === 'H') this.hEdges[entry.r][entry.c] = bits[i] || 0;
      else this.vEdges[entry.r][entry.c] = bits[i] || 0;
    }
  }

  // Get adjacency list for graph walking
  getAdjacency() {
    const key = (r, c) => `${r},${c}`;
    const adj = {};
    const ensureNode = (r, c) => { if (!adj[key(r,c)]) adj[key(r,c)] = []; };

    // H edges
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS - 1; c++) {
        if (this.hEdges[r][c]) {
          ensureNode(r, c); ensureNode(r, c + 1);
          adj[key(r,c)].push({ r, c: c+1, type: 'H' });
          adj[key(r,c+1)].push({ r, c, type: 'H' });
        }
      }
    }
    // V edges
    for (let r = 0; r < ROWS - 1; r++) {
      for (let c = 0; c < COLS; c++) {
        if (this.vEdges[r][c]) {
          ensureNode(r, c); ensureNode(r + 1, c);
          adj[key(r,c)].push({ r: r+1, c, type: 'V' });
          adj[key(r+1,c)].push({ r, c, type: 'V' });
        }
      }
    }
    // Diagonal edges — arcs store their canonical direction (r1,c1)→(r2,c2)
    // so the renderer can always produce the correct bezier curve.
    for (const e of this.dEdges) {
      ensureNode(e.r1, e.c1); ensureNode(e.r2, e.c2);
      const t = e.type === 'arc' ? 'ARC' : 'DIAG';
      adj[key(e.r1,e.c1)].push({ r: e.r2, c: e.c2, type: t, arcFrom: t === 'ARC' ? {r:e.r1,c:e.c1} : null });
      adj[key(e.r2,e.c2)].push({ r: e.r1, c: e.c1, type: t, arcFrom: t === 'ARC' ? {r:e.r1,c:e.c1} : null });
    }

    return adj;
  }
}

// ─── TextEncoder ─────────────────────────────────────────────────────
class TextEncoder_ {
  static charToCode(ch) {
    const idx = CHARSET.indexOf(ch);
    return idx >= 0 ? idx : -1;
  }

  static codeToChar(code) {
    return code >= 0 && code < CHARSET.length ? CHARSET[code] : '?';
  }

  static validate(text) {
    const upper = text.toUpperCase();
    for (const ch of upper) {
      if (TextEncoder_.charToCode(ch) < 0) return { valid: false, char: ch };
    }
    return { valid: true };
  }

  static computeChecksum(charCodes) {
    let xor = 0;
    for (const c of charCodes) xor ^= c;
    return xor & 0x7; // 3 bits
  }

  static encode(text, variant = 0) {
    const upper = text.toUpperCase();
    const validation = TextEncoder_.validate(upper);
    if (!validation.valid)
      throw new Error(`Invalid character: "${validation.char}"`);

    // Split into chunks of MAX_CHARS
    const chunks = [];
    for (let i = 0; i < upper.length; i += MAX_CHARS)
      chunks.push(upper.slice(i, i + MAX_CHARS));
    if (chunks.length === 0) chunks.push('');

    const grids = chunks.map((chunk, chunkIdx) => {
      const grid = new CircuitGrid();
      const charCodes = [];
      for (const ch of chunk) charCodes.push(TextEncoder_.charToCode(ch));

      // Build bit stream: [5-bit length][3-bit checksum][6-bit × N chars][zero-pad]
      const dataBits = new Array(TOTAL_BITS).fill(0);
      let pos = 0;

      // 5-bit length
      const len = charCodes.length;
      for (let b = 4; b >= 0; b--) dataBits[pos++] = (len >> b) & 1;

      // 3-bit checksum
      const chk = TextEncoder_.computeChecksum(charCodes);
      for (let b = 2; b >= 0; b--) dataBits[pos++] = (chk >> b) & 1;

      // 6-bit per character
      for (const code of charCodes)
        for (let b = 5; b >= 0; b--) dataBits[pos++] = (code >> b) & 1;

      // Derive data-dependent seed so different text → different random fill
      const dataSeed = charCodes.reduce((acc, code, idx) =>
        (acc + code * (idx + 1) * 7919) | 0, 0) >>> 0;

      // 1) Load data-only edges
      grid.fromBitArray(dataBits);

      // 2) Add aesthetic arcs/diags at data-edge corners
      AestheticSolver.fillDiagonals(grid, variant, dataSeed);

      // 3) Adaptive random H/V fill — balanced per 2D quadrant (4 cols × 2 rows).
      //    Uses grid position (r,c) + dataSeed for hash, NOT bit index.
      //    Sparser quadrants get more fill to even out spatial density.
      //    Pattern selection is variant-independent (never 111 = all-on).
      //    Decoding: AND all 3 variants → only data bits survive.
      const QC = 4, QR = 2, NQ = QC * QR;
      const midRow = Math.floor(ROWS / 2); // row 2 splits top/bottom
      const getQuadrant = (r, c, maxC) => {
        const qi = Math.min(Math.floor(c / (maxC + 1) * QC), QC - 1);
        const qj = r < midRow ? 0 : 1;
        return qj * QC + qi;
      };

      const map = CircuitGrid._buildBitMap();
      const currentBits = grid.toBitArray();

      // Count existing edges per quadrant
      const qExisting = new Array(NQ).fill(0);
      for (let i = 0; i < TOTAL_BITS; i++) {
        if (!currentBits[i]) continue;
        const e = map[i];
        const maxC = e.type === 'H' ? COLS - 2 : COLS - 1;
        qExisting[getQuadrant(e.r, e.c, maxC)]++;
      }

      // Collect empty slots grouped by quadrant
      const qEmpty = Array.from({length: NQ}, () => []);
      for (let r = 0; r < ROWS; r++)
        for (let c = 0; c < COLS - 1; c++) {
          if (grid.getH(r, c)) continue;
          const qi = getQuadrant(r, c, COLS - 2);
          const h = AestheticSolver.hash(r, c, dataSeed + 99, 0);
          qEmpty[qi].push({ type: 'H', r, c, hash: h, pattern: (h % 6) + 1 });
        }
      for (let r = 0; r < ROWS - 1; r++)
        for (let c = 0; c < COLS; c++) {
          if (grid.getV(r, c)) continue;
          const qi = getQuadrant(r, c, COLS - 1);
          const h = AestheticSolver.hash(r, c, dataSeed + 199, 0);
          qEmpty[qi].push({ type: 'V', r, c, hash: h, pattern: (h % 6) + 1 });
        }

      // Target: fill grid to ~55 visual edges total (H/V + diagonals → ~44% pixel coverage).
      // Count diagonals too since they contribute to visual density.
      // Each selected slot has ~50% chance of fillBit=1 per variant, so we
      // select ~2× the needed count to compensate.
      const totalHV = qExisting.reduce((a, b) => a + b, 0);
      const totalVisual = totalHV + grid.dEdges.length + grid.smoothCorners.size;
      const TARGET_VISUAL = 58;
      const totalNeeded = Math.max(0, TARGET_VISUAL - totalVisual);
      const selectNeeded = totalNeeded * 2; // ~50% fill rate per variant
      const basePerQ = selectNeeded / NQ;
      const avgExisting = totalHV / NQ;
      // Build set of H/V edges blocked from random fill.
      const arcBlockedHV = new Set();

      // 1) Smooth corners: block opposite-side edges that cross the curve's belly
      //    AND block all non-L-corner edges at the bend node to keep its degree = 2.
      //    The renderer only smooths corners at degree-2 chain nodes.
      for (const [bendKey, arc] of grid.smoothCorners) {
        const [br, bc] = bendKey.split(',').map(Number);
        const {r1, c1, r2, c2} = arc;
        // Block opposite-side edges (cross the curve belly)
        const hc = Math.min(c1, c2);
        if (hc >= 0 && hc < COLS - 1) arcBlockedHV.add(`H:${r2},${hc}`);
        const vr = Math.min(r1, r2);
        if (vr >= 0 && vr < ROWS - 1) arcBlockedHV.add(`V:${vr},${c1}`);
        // Block all H/V edges at bend node except the two L-corner edges.
        // This prevents random fill from increasing the bend's degree beyond 2.
        const lcH = `H:${br},${Math.min(bc, c1 === bc ? c1 : (c2 === bc ? c2 : bc))}`;
        const lcV = `V:${Math.min(br, r1 === br ? r1 : (r2 === br ? r2 : br))},${bc}`;
        // Compute which H and V are the L-corner edges
        const lcHkey = (r1 === br) ? `H:${br},${Math.min(bc, c1)}` : `H:${br},${Math.min(bc, c2)}`;
        const lcVkey = (c1 === bc) ? `V:${Math.min(br, r1)},${bc}` : `V:${Math.min(br, r2)},${bc}`;
        // Block all 4 possible edges at bend, except the 2 L-corner edges
        if (bc > 0) { const k = `H:${br},${bc-1}`; if (k !== lcHkey) arcBlockedHV.add(k); }
        if (bc < COLS-1) { const k = `H:${br},${bc}`; if (k !== lcHkey) arcBlockedHV.add(k); }
        if (br > 0) { const k = `V:${br-1},${bc}`; if (k !== lcVkey) arcBlockedHV.add(k); }
        if (br < ROWS-1) { const k = `V:${br},${bc}`; if (k !== lcVkey) arcBlockedHV.add(k); }
      }

      // 2) Block opposite-side edges for fill diagonal arcs
      for (const d of grid.dEdges) {
        if (d.type !== 'arc') continue;
        const {r1, c1, r2, c2} = d;
        const hc = Math.min(c1, c2);
        if (hc >= 0 && hc < COLS - 1) arcBlockedHV.add(`H:${r2},${hc}`);
        const vr = Math.min(r1, r2);
        if (vr >= 0 && vr < ROWS - 1) arcBlockedHV.add(`V:${vr},${c1}`);
      }

      // Check if adding an H/V edge would complete a triangle with an existing diagonal
      const hvWouldTriangle = (type, r, c) => {
        // An H edge connects (r,c)-(r,c+1); a V edge connects (r,c)-(r+1,c)
        // Check all diagonals touching these two nodes
        for (const d of grid.dEdges) {
          const dr1 = d.r1, dc1 = d.c1, dr2 = d.r2, dc2 = d.c2;
          if (type === 'H') {
            // H edge: (r,c)-(r,c+1). Triangle if diagonal has one end at
            // a node that's H/V-connected to both (r,c) and (r,c+1)
            // The diagonal endpoints + this H edge form a triangle if:
            // one diagonal endpoint == (r,c) and the other is V-adjacent to (r,c+1), or
            // one diagonal endpoint == (r,c+1) and the other is V-adjacent to (r,c), etc.
            const nodes = [[r, c], [r, c + 1]];
            for (const [nr, nc] of nodes) {
              // Is this node a diagonal endpoint?
              let otherR, otherC;
              if (dr1 === nr && dc1 === nc) { otherR = dr2; otherC = dc2; }
              else if (dr2 === nr && dc2 === nc) { otherR = dr1; otherC = dc1; }
              else continue;
              // Is the other diagonal endpoint H/V-connected to the other H-edge node?
              const [ar, ac] = nr === r && nc === c ? [r, c + 1] : [r, c];
              const connected =
                (otherR === ar && Math.abs(otherC - ac) === 1 && grid.getH(ar, Math.min(otherC, ac))) ||
                (otherC === ac && Math.abs(otherR - ar) === 1 && grid.getV(Math.min(otherR, ar), ac));
              if (connected) return true;
            }
          } else {
            // V edge: (r,c)-(r+1,c)
            const nodes = [[r, c], [r + 1, c]];
            for (const [nr, nc] of nodes) {
              let otherR, otherC;
              if (dr1 === nr && dc1 === nc) { otherR = dr2; otherC = dc2; }
              else if (dr2 === nr && dc2 === nc) { otherR = dr1; otherC = dc1; }
              else continue;
              const [ar, ac] = nr === r && nc === c ? [r + 1, c] : [r, c];
              const connected =
                (otherR === ar && Math.abs(otherC - ac) === 1 && grid.getH(ar, Math.min(otherC, ac))) ||
                (otherC === ac && Math.abs(otherR - ar) === 1 && grid.getV(Math.min(otherR, ar), ac));
              if (connected) return true;
            }
          }
        }
        return false;
      };

      for (let qi = 0; qi < NQ; qi++) {
        const deficit = Math.max(0, avgExisting - qExisting[qi]);
        const target = Math.round(basePerQ + deficit * 2);
        qEmpty[qi].sort((a, b) => a.hash - b.hash);
        let selected = 0;
        for (const slot of qEmpty[qi]) {
          if (selected >= target) break;
          selected++;
          const fillBit = (slot.pattern >> (2 - variant)) & 1;
          if (!fillBit) continue;
          if (hvWouldTriangle(slot.type, slot.r, slot.c)) continue;
          if (arcBlockedHV.has(`${slot.type}:${slot.r},${slot.c}`)) continue;
          if (slot.type === 'H') grid.setH(slot.r, slot.c, 1);
          else grid.setV(slot.r, slot.c, 1);
        }
      }

      return grid;
    });

    return grids;
  }
}

// ─── Union-Find (cycle detection) ────────────────────────────────────
class UnionFind {
  constructor() { this.parent = {}; this.rank = {}; }
  find(x) {
    if (!(x in this.parent)) { this.parent[x] = x; this.rank[x] = 0; }
    if (this.parent[x] !== x) this.parent[x] = this.find(this.parent[x]);
    return this.parent[x];
  }
  connected(a, b) { return this.find(a) === this.find(b); }
  union(a, b) {
    const ra = this.find(a), rb = this.find(b);
    if (ra === rb) return false;
    if (this.rank[ra] < this.rank[rb]) this.parent[ra] = rb;
    else if (this.rank[ra] > this.rank[rb]) this.parent[rb] = ra;
    else { this.parent[rb] = ra; this.rank[ra]++; }
    return true;
  }
}

// ─── AestheticSolver ─────────────────────────────────────────────────
class AestheticSolver {
  static hash(r, c, seed, variant = 0) {
    let h = (r * 131 + c * 997 + seed * 7919 + variant * 104729) | 0;
    h = ((h >>> 16) ^ h) * 0x45d9f3b | 0;
    h = ((h >>> 16) ^ h) * 0x45d9f3b | 0;
    return ((h >>> 16) ^ h) >>> 0;
  }

  static fillDiagonals(grid, variant = 0, dataSeed = 0) {
    const usedCells = new Set();
    const cellKey = (r, c) => `${r},${c}`;
    const nodeId = (r, c) => `${r},${c}`;
    const MAX_DEG = 4;
    const QC = 4, midRow = Math.floor(ROWS / 2);
    const getQuadrant = (r, c) => (r < midRow ? 0 : QC) + Math.min(Math.floor(c / COLS * QC), QC - 1);
    const NQ = QC * 2;

    // Build Union-Find from existing H/V edges to track connectivity
    const uf = new UnionFind();
    for (let r = 0; r < ROWS; r++)
      for (let c = 0; c < COLS - 1; c++)
        if (grid.getH(r, c)) uf.union(nodeId(r, c), nodeId(r, c + 1));
    for (let r = 0; r < ROWS - 1; r++)
      for (let c = 0; c < COLS; c++)
        if (grid.getV(r, c)) uf.union(nodeId(r, c), nodeId(r + 1, c));

    // Check if diagonal (r1,c1)-(r2,c2) would form a triangle with H/V edges.
    // A triangle occurs when both endpoints share a common H/V neighbor.
    const wouldFormTriangle = (r1, c1, r2, c2) => {
      if (r1 === r2 || c1 === c2) return false; // not a diagonal
      // The two other corners of the 2×2 cell containing this diagonal
      const corners = [{r: r1, c: c2}, {r: r2, c: c1}];
      for (const n of corners) {
        // Is n connected to (r1,c1) via H or V?
        const toA = (n.r === r1 && Math.abs(n.c - c1) === 1 && grid.getH(n.r, Math.min(n.c, c1))) ||
                    (n.c === c1 && Math.abs(n.r - r1) === 1 && grid.getV(Math.min(n.r, r1), n.c));
        if (!toA) continue;
        // Is n connected to (r2,c2) via H or V?
        const toB = (n.r === r2 && Math.abs(n.c - c2) === 1 && grid.getH(n.r, Math.min(n.c, c2))) ||
                    (n.c === c2 && Math.abs(n.r - r2) === 1 && grid.getV(Math.min(n.r, r2), n.c));
        if (toB) return true;
      }
      return false;
    };

    // Check if an arc from (r1,c1)→(r2,c2) would have its midpoint crossed by
    // an existing H/V edge. The arc departs horizontally (from r1) and arrives
    // vertically (into c2), curving through the cell interior. The opposite-side
    // edges that cut across the arc's belly are:
    //   H edge at row r2 between min(c1,c2) (opposite horizontal)
    //   V edge at col c1 between min(r1,r2) (opposite vertical)
    const arcCrossesExistingHV = (r1, c1, r2, c2) => {
      const hc = Math.min(c1, c2);
      if (hc >= 0 && hc < COLS - 1 && grid.getH(r2, hc)) return true;
      const vr = Math.min(r1, r2);
      if (vr >= 0 && vr < ROWS - 1 && grid.getV(vr, c1)) return true;
      return false;
    };

    // Mark a cell and ALL 8 surrounding cells as used (blocks future diagonals nearby).
    // With stroke-width 61.7 on a 111.1 grid, diagonals in adjacent cells visually cross.
    const markCellAndNeighbors = (r, c) => {
      for (let dr = -1; dr <= 1; dr++)
        for (let dc = -1; dc <= 1; dc++) {
          const nr = r + dr, nc = c + dc;
          if (nr >= 0 && nr < ROWS - 1 && nc >= 0 && nc < COLS - 1)
            usedCells.add(cellKey(nr, nc));
        }
    };

    // Helper: try to add a diagonal — rejects straight-line triangles, cycles, and degree overflow.
    // Arcs are exempt from the triangle check: they curve outward so the enclosed
    // region is filled by the thick stroke, unlike straight lines which leave a visible hole.
    // Arcs are rejected if existing H/V edges would cross through their midpoint.
    const tryAdd = (r1, c1, r2, c2, type, skipCycleCheck = false) => {
      if (type !== 'arc' && wouldFormTriangle(r1, c1, r2, c2)) return false;
      if (type === 'arc' && arcCrossesExistingHV(r1, c1, r2, c2)) return false;
      const a = nodeId(r1, c1), b = nodeId(r2, c2);
      if (!skipCycleCheck && uf.connected(a, b)) return false;
      if (grid.getNodeDegree(r1, c1) >= MAX_DEG) return false;
      if (grid.getNodeDegree(r2, c2) >= MAX_DEG) return false;
      grid.addDiag(r1, c1, r2, c2, type);
      uf.union(a, b);
      return true;
    };

    // Count existing edge weight per quadrant for adaptive fill
    const qWeight = new Array(NQ).fill(0);
    for (let r = 0; r < ROWS; r++)
      for (let c = 0; c < COLS - 1; c++)
        if (grid.getH(r, c)) qWeight[getQuadrant(r, c)]++;
    for (let r = 0; r < ROWS - 1; r++)
      for (let c = 0; c < COLS; c++)
        if (grid.getV(r, c)) qWeight[getQuadrant(r, c)]++;
    const avgWeight = qWeight.reduce((a, b) => a + b, 0) / NQ;

    // Pass 1: Smooth corners at L-corners — mark bend nodes for bezier rendering.
    // Instead of adding separate diagonal arc edges, we mark the bend node so the
    // renderer smooths the H→V (or V→H) corner with a quarter-circle bezier.
    // This eliminates the "L covering the arc" overlap issue.
    // Only smooth at degree-2 nodes — the chain only extends through degree-2 nodes,
    // and nodes with more edges have data that would be hidden by smoothing.
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (grid.getNodeDegreeHV(r, c) !== 2) continue;
        const corners = AestheticSolver.findLCorners(grid, r, c);
        for (const corner of corners) {
          const cr = Math.min(corner.r1, corner.r2);
          const cc = Math.min(corner.c1, corner.c2);
          const ck = cellKey(cr, cc);
          if (usedCells.has(ck)) continue;

          // Use variant-independent hash so smooth corners are consistent across
          // all 3 variants. This is essential: the decoder must see the same H/V
          // edges in all variants for the AND-intersection to work correctly.
          const h = AestheticSolver.hash(cr, cc, dataSeed, 0);
          // Keep ~70% baseline, up to ~90% in sparse quadrants
          const qi = getQuadrant(cr, cc);
          const sparsity = Math.max(0, avgWeight - qWeight[qi]);
          const keepThresh = 7 + Math.min(Math.floor(sparsity * 0.5), 2);
          if (h % 10 < (10 - keepThresh)) continue;

          // Check if opposite H/V edges would cross the smooth curve
          if (arcCrossesExistingHV(corner.r1, corner.c1, corner.r2, corner.c2)) continue;

          // Mark the bend node for smooth rendering (don't add a diagonal edge)
          grid.smoothCorners.set(`${r},${c}`, { r1: corner.r1, c1: corner.c1, r2: corner.r2, c2: corner.c2 });
          markCellAndNeighbors(cr, cc);
          qWeight[qi]++;
          break; // One smooth corner per bend node
        }
      }
    }

    // Pass 2: Fill diagonals — prefer sparse quadrants
    // Collect candidates, sort by quadrant sparsity then hash
    const diagCandidates = [];
    for (let r = 0; r < ROWS - 1; r++) {
      for (let c = 0; c < COLS - 1; c++) {
        const ck = cellKey(r, c);
        if (usedCells.has(ck)) continue;
        const h = AestheticSolver.hash(r, c, dataSeed + 1, variant);
        const qi = getQuadrant(r, c);
        diagCandidates.push({ r, c, h, qi, ck });
      }
    }
    // Sort: sparsest quadrant first, then by hash within each
    diagCandidates.sort((a, b) => {
      const da = qWeight[a.qi], db = qWeight[b.qi];
      if (da !== db) return da - db; // sparse first
      return a.h - b.h;
    });

    let diagCount = 0;
    const maxDiags = Math.round((ROWS - 1) * (COLS - 1) * 0.10); // ~10% of cells
    for (const cand of diagCandidates) {
      if (diagCount >= maxDiags) break;
      const {r, c, h, qi, ck} = cand;
      // Re-check at placement time — earlier placements may have blocked this cell
      if (usedCells.has(ck)) continue;

      const dir = h % 2;
      const surrounding = AestheticSolver.countCellEdges(grid, r, c);
      const type = surrounding >= 1 ? 'arc' : 'line';
      let added = false;
      if (dir === 0) added = tryAdd(r, c, r + 1, c + 1, type);
      else added = tryAdd(r, c + 1, r + 1, c, type);
      if (added) {
        markCellAndNeighbors(r, c);
        qWeight[qi]++;
        diagCount++;
      }
    }
  }

  static findLCorners(grid, r, c) {
    const corners = [];
    const deg = grid.getNodeDegreeHV(r, c);
    if (deg < 2) return corners;

    const neighbors = [];
    if (c > 0 && grid.getH(r, c-1)) neighbors.push({r, c: c-1, dir: 'L'});
    if (c < COLS-1 && grid.getH(r, c)) neighbors.push({r, c: c+1, dir: 'R'});
    if (r > 0 && grid.getV(r-1, c)) neighbors.push({r: r-1, c, dir: 'U'});
    if (r < ROWS-1 && grid.getV(r, c)) neighbors.push({r: r+1, c, dir: 'D'});

    // Find all pairs that form right angles.
    // Always put the H-connected neighbor as r1 and V-connected as r2.
    // This ensures the arc bezier departs horizontally (matching the H-edge)
    // and arrives vertically (matching the V-edge).
    for (let i = 0; i < neighbors.length; i++) {
      for (let j = i + 1; j < neighbors.length; j++) {
        const a = neighbors[i], b = neighbors[j];
        const aIsH = (a.dir === 'L' || a.dir === 'R');
        const bIsH = (b.dir === 'L' || b.dir === 'R');
        if (aIsH === bIsH) continue; // same axis, not a corner
        if (aIsH) {
          corners.push({ r1: a.r, c1: a.c, r2: b.r, c2: b.c });
        } else {
          corners.push({ r1: b.r, c1: b.c, r2: a.r, c2: a.c });
        }
      }
    }
    return corners;
  }

  static countCellEdges(grid, r, c) {
    let count = 0;
    if (grid.getH(r, c)) count++;
    if (r + 1 < ROWS && grid.getH(r + 1, c)) count++;
    if (grid.getV(r, c)) count++;
    if (c + 1 < COLS && grid.getV(r, c + 1)) count++;
    return count;
  }
}

// ─── SVGRenderer ─────────────────────────────────────────────────────
class SVGRenderer {
  static render(grids) {
    const panelCount = grids.length;
    const totalHeight = panelCount * VB_H + (panelCount - 1) * PANEL_GAP;
    const paths = [];

    for (let p = 0; p < panelCount; p++) {
      const yOff = p * (VB_H + PANEL_GAP);
      const gridPaths = SVGRenderer.renderGrid(grids[p], yOff);
      paths.push(...gridPaths);
    }

    return [
      `<svg width="${VB_W}" height="${totalHeight}" viewBox="0 0 ${VB_W} ${totalHeight}" fill="none" xmlns="http://www.w3.org/2000/svg">`,
      ...paths.map(d => `<path d="${d}" stroke="white" stroke-width="${SW}" stroke-linecap="round" stroke-linejoin="round"/>`),
      `</svg>`
    ].join('\n');
  }

  static renderGrid(grid, yOff) {
    const adj = grid.getAdjacency();
    const visitedEdges = new Set();
    const edgeKey = (r1, c1, r2, c2) => {
      if (r1 < r2 || (r1 === r2 && c1 < c2)) return `${r1},${c1}-${r2},${c2}`;
      return `${r2},${c2}-${r1},${c1}`;
    };

    const allPaths = [];
    const fmt = (v) => Math.round(v * 1000) / 1000;

    // Render fill-diagonal arcs as separate standalone paths
    const arcEdgeKeys = new Set();
    for (const e of grid.dEdges) {
      if (e.type !== 'arc') continue;
      const ek = edgeKey(e.r1, e.c1, e.r2, e.c2);
      arcEdgeKeys.add(ek);
      const sx = nodeX(e.c1), sy = nodeY(e.r1) + yOff;
      const ex = nodeX(e.c2), ey = nodeY(e.r2) + yOff;
      const dx = ex - sx, dy = ey - sy;
      allPaths.push(`M${fmt(sx)} ${fmt(sy)}C${fmt(sx + dx * K)} ${fmt(sy)} ${fmt(ex)} ${fmt(ey - dy * K)} ${fmt(ex)} ${fmt(ey)}`);
    }

    // Remove fill-diagonal ARC edges from adjacency so they don't chain
    for (const nodeKey in adj) {
      adj[nodeKey] = adj[nodeKey].filter(nb => {
        if (nb.type !== 'ARC') return true;
        const [r, c] = nodeKey.split(',').map(Number);
        return !arcEdgeKeys.has(edgeKey(r, c, nb.r, nb.c));
      });
      if (adj[nodeKey].length === 0) delete adj[nodeKey];
    }

    // Build chains
    const nodeKeys = Object.keys(adj);
    nodeKeys.sort();
    const degrees = {};
    for (const nk of nodeKeys) degrees[nk] = adj[nk].length;
    const startNodes = nodeKeys.filter(nk => degrees[nk] === 1);
    const otherNodes = nodeKeys.filter(nk => degrees[nk] !== 1);

    const tryChain = (startKey) => {
      const [sr, sc] = startKey.split(',').map(Number);
      const neighbors = adj[startKey];
      for (const nb of neighbors) {
        const ek = edgeKey(sr, sc, nb.r, nb.c);
        if (visitedEdges.has(ek)) continue;

        const chain = [{ r: sr, c: sc }];
        let nr = nb.r, nc = nb.c;
        visitedEdges.add(ek);
        chain.push({ r: nr, c: nc, type: nb.type });

        while (chain.length - 1 < MAX_CHAIN) {
          const nk = `${nr},${nc}`;
          const nbs = adj[nk];
          if (!nbs) break;
          let found = false;
          for (const next of nbs) {
            const nek = edgeKey(nr, nc, next.r, next.c);
            if (visitedEdges.has(nek)) continue;
            if (degrees[nk] !== 2) { found = false; break; }
            visitedEdges.add(nek);
            nr = next.r; nc = next.c;
            chain.push({ r: nr, c: nc, type: next.type });
            found = true;
            break;
          }
          if (!found) break;
        }

        if (chain.length >= 2) {
          allPaths.push(SVGRenderer.chainToPathD(chain, yOff, grid.smoothCorners));
        }
      }
    };

    for (const nk of startNodes) tryChain(nk);
    for (const nk of otherNodes) tryChain(nk);
    return allPaths;
  }

  static chainToPathD(chain, yOff, smoothCorners) {
    const fmt = (v) => Math.round(v * 1000) / 1000;
    const parts = [];
    parts.push(`M${fmt(nodeX(chain[0].c))} ${fmt(nodeY(chain[0].r) + yOff)}`);
    let lastWasBezier = false; // Prevents H/V merge from overwriting a bezier

    for (let i = 1; i < chain.length; i++) {
      const prev = chain[i - 1];
      const cur = chain[i];
      const type = cur.type;
      const cx = fmt(nodeX(cur.c));
      const cy = fmt(nodeY(cur.r) + yOff);

      // Smooth corner: when cur is a marked bend node and the chain transitions
      // H→V or V→H, replace the sharp 90° corner with a quarter-circle bezier
      // from prev directly to next, skipping the bend node.
      // Only apply smooth corner if chain has > 3 nodes. With exactly 3 nodes the
      // bezier would be the entire path (M+C), indistinguishable from a standalone
      // fill-diagonal arc, which breaks decoder H/V inference.
      if (smoothCorners && chain.length > 3 && smoothCorners.has(`${cur.r},${cur.c}`) && i + 1 < chain.length) {
        const next = chain[i + 1];
        const nextType = next.type;
        if ((type === 'H' && nextType === 'V') || (type === 'V' && nextType === 'H')) {
          const px = nodeX(prev.c), py = nodeY(prev.r) + yOff;
          const nx = nodeX(next.c), ny = nodeY(next.r) + yOff;
          const dx = nx - px, dy = ny - py;
          if (type === 'H') {
            // H→V: depart horizontally from prev, arrive vertically into next
            parts.push(`C${fmt(px + dx*K)} ${fmt(py)} ${fmt(nx)} ${fmt(ny - dy*K)} ${fmt(nx)} ${fmt(ny)}`);
          } else {
            // V→H: depart vertically from prev, arrive horizontally into next
            parts.push(`C${fmt(px)} ${fmt(py + dy*K)} ${fmt(nx - dx*K)} ${fmt(ny)} ${fmt(nx)} ${fmt(ny)}`);
          }
          i++; // Skip next node (already consumed by the bezier)
          lastWasBezier = true;
          continue;
        }
      }

      if (type === 'H') {
        if (!lastWasBezier && i > 1 && chain[i-1].type === 'H' && cur.r === chain[i-2].r) {
          parts[parts.length - 1] = `H${cx}`;
        } else {
          parts.push(`H${cx}`);
        }
      } else if (type === 'V') {
        if (!lastWasBezier && i > 1 && chain[i-1].type === 'V' && cur.c === chain[i-2].c) {
          parts[parts.length - 1] = `V${cy}`;
        } else {
          parts.push(`V${cy}`);
        }
      } else if (type === 'DIAG') {
        parts.push(`L${cx} ${cy}`);
      }
      lastWasBezier = false;
    }

    return parts.join('');
  }
}

// ─── PatternDecoder ──────────────────────────────────────────────────
class PatternDecoder {
  static snapToGrid(x, y, yOff = 0) {
    const adjY = y - yOff;
    const col = Math.round((x - PAD) / CELL);
    const row = Math.round((adjY - PAD) / CELL);
    return {
      r: Math.max(0, Math.min(ROWS - 1, row)),
      c: Math.max(0, Math.min(COLS - 1, col))
    };
  }

  // Extract grids (bit arrays per panel) from a single SVG string
  static _extractGrids(svgString) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(svgString, 'image/svg+xml');
    const paths = doc.querySelectorAll('path');

    if (paths.length === 0) return null;

    const svg = doc.querySelector('svg');
    const vb = svg?.getAttribute('viewBox')?.split(/\s+/).map(Number);
    const totalHeight = vb ? vb[3] : VB_H;
    const panelCount = Math.max(1, Math.round((totalHeight + PANEL_GAP) / (VB_H + PANEL_GAP)));

    const panelBits = [];
    for (let p = 0; p < panelCount; p++) {
      const yOff = p * (VB_H + PANEL_GAP);
      const grid = new CircuitGrid();

      for (const path of paths) {
        const d = path.getAttribute('d');
        if (!d) continue;
        const edges = PatternDecoder.parsePath(d, yOff);
        for (const edge of edges) {
          if (edge.type === 'H') {
            const minC = Math.min(edge.c1, edge.c2);
            const maxC = Math.max(edge.c1, edge.c2);
            for (let c = minC; c < maxC; c++) {
              if (edge.r >= 0 && edge.r < ROWS && c >= 0 && c < COLS - 1)
                grid.setH(edge.r, c, 1);
            }
          } else if (edge.type === 'V') {
            const minR = Math.min(edge.r1, edge.r2);
            const maxR = Math.max(edge.r1, edge.r2);
            for (let r = minR; r < maxR; r++) {
              if (edge.c >= 0 && edge.c < COLS && r >= 0 && r < ROWS - 1)
                grid.setV(r, edge.c, 1);
            }
          }
        }
      }
      panelBits.push(grid.toBitArray());
    }
    return panelBits;
  }

  // Decode bits from a panel into text
  static _decodeBits(bits) {
    let pos = 0;
    let len = 0;
    for (let b = 4; b >= 0; b--) len |= (bits[pos++] << b);

    let chk = 0;
    for (let b = 2; b >= 0; b--) chk |= (bits[pos++] << b);

    if (len > MAX_CHARS)
      return { text: '', valid: false, error: `Invalid length: ${len}` };

    const charCodes = [];
    for (let i = 0; i < len; i++) {
      let code = 0;
      for (let b = 5; b >= 0; b--) code |= (bits[pos++] << b);
      charCodes.push(code);
    }

    const expectedChk = TextEncoder_.computeChecksum(charCodes);
    if (chk !== expectedChk)
      return { text: '', valid: false, error: `Checksum mismatch (got ${chk}, expected ${expectedChk})` };

    const text = charCodes.map(c => TextEncoder_.codeToChar(c)).join('');
    return { text, valid: true };
  }

  // Decode from 3 variant SVGs by AND-intersecting their H/V edges.
  // Edges present in all 3 = data, edges that differ = random filler.
  static decode3(svgStrings) {
    if (!Array.isArray(svgStrings) || svgStrings.length !== 3)
      return { text: '', valid: false, error: 'Requires exactly 3 variant SVGs' };

    const allPanelBits = svgStrings.map(s => PatternDecoder._extractGrids(s));
    if (allPanelBits.some(p => !p))
      return { text: '', valid: false, error: 'Failed to parse one or more SVGs' };

    const panelCount = allPanelBits[0].length;
    if (!allPanelBits.every(p => p.length === panelCount))
      return { text: '', valid: false, error: 'Variant panel counts do not match' };

    const results = [];
    for (let p = 0; p < panelCount; p++) {
      // AND all 3 variants: bit = 1 only if all 3 have it
      const bits = new Array(TOTAL_BITS);
      for (let i = 0; i < TOTAL_BITS; i++) {
        bits[i] = allPanelBits[0][p][i] & allPanelBits[1][p][i] & allPanelBits[2][p][i];
      }
      results.push(PatternDecoder._decodeBits(bits));
    }

    const allValid = results.every(r => r.valid);
    const fullText = results.map(r => r.text).join('');
    const firstError = results.find(r => !r.valid);
    return { text: fullText, valid: allValid, panels: results, error: firstError?.error || null };
  }

  // Single-SVG decode (legacy, works only on SVGs without random fill)
  static decode(svgString) {
    const panelBits = PatternDecoder._extractGrids(svgString);
    if (!panelBits)
      return { text: '', valid: false, error: 'No paths found in SVG' };

    const results = panelBits.map(bits => PatternDecoder._decodeBits(bits));
    const allValid = results.every(r => r.valid);
    const fullText = results.map(r => r.text).join('');
    const firstError = results.find(r => !r.valid);
    return { text: fullText, valid: allValid, panels: results, error: firstError?.error || null };
  }

  static parsePath(d, yOff) {
    const edges = [];
    // Y-range for this panel (with half-cell tolerance)
    const yMin = yOff + PAD - CELL * 0.5;
    const yMax = yOff + PAD + (ROWS - 1) * CELL + CELL * 0.5;
    const inRange = (y) => y >= yMin && y <= yMax;

    // Tokenize the path d attribute
    const tokens = d.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/gi) || [];
    let cx = 0, cy = 0; // Current point
    // Count draw commands (non-M) to distinguish standalone fill-diagonal arcs
    // (just M+C, drawCmds=1) from smooth corner beziers within longer chains
    // (drawCmds > 1). Standalone arcs are aesthetic and must not infer H/V edges.
    const drawCmds = tokens.filter(t => t[0] !== 'M').length;
    for (const token of tokens) {
      const cmd = token[0];
      const nums = token.slice(1).trim().split(/[\s,]+/).map(Number).filter(n => !isNaN(n));

      switch (cmd) {
        case 'M':
          cx = nums[0]; cy = nums[1];
          break;
        case 'H': {
          const nx = nums[0];
          if (inRange(cy)) {
            const snap1 = PatternDecoder.snapToGrid(cx, cy, yOff);
            const snap2 = PatternDecoder.snapToGrid(nx, cy, yOff);
            if (snap1.r === snap2.r) {
              edges.push({ type: 'H', r: snap1.r, c1: snap1.c, c2: snap2.c });
            }
          }
          cx = nx;
          break;
        }
        case 'V': {
          const ny = nums[0];
          if (inRange(cy) && inRange(ny)) {
            const snap1 = PatternDecoder.snapToGrid(cx, cy, yOff);
            const snap2 = PatternDecoder.snapToGrid(cx, ny, yOff);
            if (snap1.c === snap2.c) {
              edges.push({ type: 'V', c: snap1.c, r1: snap1.r, r2: snap2.r });
            }
          }
          cy = ny;
          break;
        }
        case 'L': {
          const nx = nums[0], ny = nums[1];
          if (inRange(cy) && inRange(ny)) {
            const snap1 = PatternDecoder.snapToGrid(cx, cy, yOff);
            const snap2 = PatternDecoder.snapToGrid(nx, ny, yOff);
            if (snap1.r === snap2.r && snap1.c !== snap2.c) {
              edges.push({ type: 'H', r: snap1.r, c1: snap1.c, c2: snap2.c });
            } else if (snap1.c === snap2.c && snap1.r !== snap2.r) {
              edges.push({ type: 'V', c: snap1.c, r1: snap1.r, r2: snap2.r });
            }
          }
          // Diagonals are ignored for decoding
          cx = nx; cy = ny;
          break;
        }
        case 'C': {
          // Cubic bezier — 6 numbers: cp1x cp1y cp2x cp2y x y
          if (nums.length >= 6) {
            const nx = nums[4], ny = nums[5];
            // Smooth corners render H→V transitions as bezier curves within chains.
            // Standalone fill-diagonal arcs (M+C only, drawCmds=1) are aesthetic and
            // must NOT infer H/V edges — they'd create false positives in the decode.
            // Only infer H/V from beziers that are part of longer chains (drawCmds > 1).
            if (drawCmds > 1 && inRange(cy) && inRange(ny)) {
              const snap1 = PatternDecoder.snapToGrid(cx, cy, yOff);
              const snap2 = PatternDecoder.snapToGrid(nx, ny, yOff);
              const dr = Math.abs(snap2.r - snap1.r);
              const dc = Math.abs(snap2.c - snap1.c);
              if (dr === 1 && dc === 1) {
                // Diagonal bezier = smooth corner. Infer bend node.
                // The bend is at (snap1.r, snap2.c) or (snap2.r, snap1.c).
                // Check control points to determine which: the first CP
                // shares Y with start (H departure) → bend at (snap1.r, snap2.c),
                // or shares X with start (V departure) → bend at (snap2.r, snap1.c).
                const cp1y = nums[1];
                const bendR = (Math.abs(cp1y - cy) < CELL * 0.3) ? snap1.r : snap2.r;
                const bendC = (bendR === snap1.r) ? snap2.c : snap1.c;
                // H edge between snap1/snap2 and bend (whichever shares the row)
                const hRow = bendR;
                const hC1 = Math.min(snap1.c === bendC ? snap2.c : snap1.c, bendC);
                edges.push({ type: 'H', r: hRow, c1: hC1, c2: hC1 + 1 });
                // V edge between snap1/snap2 and bend (whichever shares the col)
                const vCol = bendC;
                const vR1 = Math.min(snap1.r === bendR ? snap2.r : snap1.r, bendR);
                edges.push({ type: 'V', c: vCol, r1: vR1, r2: vR1 + 1 });
              }
            }
            cx = nx; cy = ny;
          }
          break;
        }
      }
    }
    return edges;
  }
}

// ─── UI Logic ────────────────────────────────────────────────────────
const VARIANT_COUNT = 3;
let currentSvgs = []; // array of 3 SVG strings
let selectedVariant = 0;

const inputText   = document.getElementById('inputText');
const charCount   = document.getElementById('charCount');
const panelCountEl = document.getElementById('panelCount');
const bitInfo     = document.getElementById('bitInfo');
const btnEncode   = document.getElementById('btnEncode');
const btnDownload = document.getElementById('btnDownload');
const btnDownloadAll = document.getElementById('btnDownloadAll');
const btnCopy     = document.getElementById('btnCopy');
const previewArea = document.getElementById('previewArea');
const svgInput    = document.getElementById('svgInput');
const btnDecode   = document.getElementById('btnDecode');
const decodedOutput = document.getElementById('decodedOutput');
const dropZone    = document.getElementById('dropZone');
const fileInput   = document.getElementById('fileInput');
const btnShare    = document.getElementById('btnShare');
const toastEl     = document.getElementById('toast');
const docModal    = document.getElementById('docModal');
const btnDocs     = document.getElementById('btnDocs');
const docClose    = document.getElementById('docClose');

btnDocs.addEventListener('click', () => docModal.classList.add('open'));
docClose.addEventListener('click', () => docModal.classList.remove('open'));
docModal.addEventListener('click', (e) => {
  if (e.target === docModal) docModal.classList.remove('open');
});

function showToast(msg) {
  toastEl.textContent = msg;
  toastEl.classList.add('show');
  setTimeout(() => toastEl.classList.remove('show'), 2000);
}

function updateInfo() {
  const text = inputText.value.toUpperCase();
  const len = text.length;
  const panels = Math.max(1, Math.ceil(len / MAX_CHARS));
  const lastPanelChars = len - (panels - 1) * MAX_CHARS;
  const bitsUsed = HEADER_BITS + Math.min(len, MAX_CHARS) * CHAR_BITS;

  charCount.textContent = `${len} character${len !== 1 ? 's' : ''} (max ${MAX_CHARS}/panel)`;
  panelCountEl.textContent = `${panels} panel${panels !== 1 ? 's' : ''}`;
  bitInfo.textContent = `${bitsUsed} / ${TOTAL_BITS} bits used`;
}

function selectVariant(index) {
  selectedVariant = index;
  const items = previewArea.querySelectorAll('.variant-item');
  items.forEach((el, i) => el.classList.toggle('selected', i === index));
}

inputText.addEventListener('input', updateInfo);

btnEncode.addEventListener('click', () => {
  const text = inputText.value.trim();
  if (!text) {
    previewArea.innerHTML = '<span class="preview-placeholder">Enter some text first</span>';
    btnDownload.disabled = true;
    btnDownloadAll.disabled = true;
    btnCopy.disabled = true;
    btnShare.disabled = true;
    currentSvgs = [];
    return;
  }

  try {
    currentSvgs = [];
    for (let v = 0; v < VARIANT_COUNT; v++) {
      const grids = TextEncoder_.encode(text, v);
      currentSvgs.push(SVGRenderer.render(grids));
    }

    // Verify decoding by AND-intersecting all 3 variants
    const decoded = PatternDecoder.decode3(currentSvgs);
    const isValid = decoded.valid && decoded.text === text.toUpperCase();

    // Build the 3-variant display
    const container = document.createElement('div');
    container.className = 'variants-grid';
    for (let v = 0; v < VARIANT_COUNT; v++) {
      const item = document.createElement('div');
      item.className = 'variant-item' + (v === selectedVariant ? ' selected' : '');
      item.innerHTML = `<span class="variant-label">Variant ${v + 1}</span>${currentSvgs[v]}`;
      item.addEventListener('click', () => selectVariant(v));
      container.appendChild(item);
    }
    previewArea.innerHTML = '';
    previewArea.appendChild(container);

    btnDownload.disabled = false;
    btnDownloadAll.disabled = false;
    btnCopy.disabled = false;
    btnShare.disabled = false;

    if (isValid) {
      showToast('3 variants encoded — decodes correctly via intersection');
    } else {
      showToast('Warning: 3-variant decode verification failed');
      console.warn('Decode mismatch:', decoded);
    }
  } catch (e) {
    const errSpan = document.createElement('span');
    errSpan.className = 'preview-placeholder';
    errSpan.style.color = '#cc6666';
    errSpan.textContent = e.message;
    previewArea.innerHTML = '';
    previewArea.appendChild(errSpan);
    showToast('Encoding error');
  }
});

btnDownload.addEventListener('click', () => {
  if (!currentSvgs.length) return;
  // Download all 3 variants (all needed for decoding)
  for (let v = 0; v < VARIANT_COUNT; v++) {
    const blob = new Blob([currentSvgs[v]], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `circuit-pattern-v${v + 1}.svg`;
    a.click();
    URL.revokeObjectURL(url);
  }
  showToast('All 3 variants downloaded');
});

btnDownloadAll.addEventListener('click', async () => {
  if (!currentSvgs.length) return;
  const text = inputText.value.trim().toUpperCase() || 'pattern';
  const folderName = text.replace(/[^A-Z0-9]/g, '_').replace(/_+/g, '_').replace(/^_|_$/g, '') || 'pattern';
  const zip = new JSZip();
  const folder = zip.folder(folderName);
  for (let v = 0; v < VARIANT_COUNT; v++) {
    folder.file(`variant-${v + 1}.svg`, currentSvgs[v]);
  }
  const blob = await zip.generateAsync({ type: 'blob' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${folderName}.zip`;
  a.click();
  URL.revokeObjectURL(url);
  showToast(`Downloaded ${folderName}.zip`);
});

btnCopy.addEventListener('click', () => {
  if (!currentSvgs.length) return;
  navigator.clipboard.writeText(currentSvgs[selectedVariant])
    .then(() => showToast(`Variant ${selectedVariant + 1} copied to clipboard`));
});

btnShare.addEventListener('click', () => {
  const text = inputText.value.trim();
  if (!text) return;
  const url = new URL(window.location.href.split('?')[0]);
  url.searchParams.set('text', text);
  navigator.clipboard.writeText(url.toString())
    .then(() => showToast('Share link copied to clipboard'));
  history.replaceState(null, '', url.toString());
});

// Split pasted text into individual SVG strings
function splitSvgs(text) {
  const svgs = [];
  const re = /<svg[\s\S]*?<\/svg>/gi;
  let match;
  while ((match = re.exec(text)) !== null) svgs.push(match[0]);
  return svgs;
}

btnDecode.addEventListener('click', () => {
  const raw = svgInput.value.trim();
  if (!raw) { decodedOutput.textContent = ''; return; }

  const svgs = splitSvgs(raw);
  let result;
  if (svgs.length >= 3) {
    result = PatternDecoder.decode3(svgs.slice(0, 3));
  } else if (svgs.length === 1) {
    // Legacy single-SVG decode (works only without random fill)
    result = PatternDecoder.decode(svgs[0]);
  } else {
    result = { valid: false, error: `Need 3 SVG variants (found ${svgs.length})` };
  }

  decodedOutput.classList.toggle('error', !result.valid);
  decodedOutput.textContent = result.valid ? result.text
    : `Error: ${result.error || 'Could not decode'}`;
});

// File drop / click (supports multiple files)
let pendingFiles = [];
dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
dropZone.addEventListener('drop', e => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
  readFiles(Array.from(e.dataTransfer.files));
});
fileInput.addEventListener('change', () => {
  readFiles(Array.from(fileInput.files));
});

function readFiles(files) {
  const svgFiles = files.filter(f => f.name.endsWith('.svg')).slice(0, 3);
  if (svgFiles.length === 0) return;

  const contents = [];
  let loaded = 0;
  svgFiles.forEach((file, i) => {
    const reader = new FileReader();
    reader.onload = () => {
      contents[i] = reader.result;
      loaded++;
      if (loaded === svgFiles.length) {
        svgInput.value = contents.join('\n\n');
        btnDecode.click();
      }
    };
    reader.readAsText(file);
  });
}

// Live preview on typing (with debounce)
let debounceTimer;
inputText.addEventListener('input', () => {
  clearTimeout(debounceTimer);
  debounceTimer = setTimeout(() => {
    if (inputText.value.trim()) btnEncode.click();
  }, 400);
});

// Self-test on load
(function selfTest() {
  const testEl = document.getElementById('testResults');
  const lines = [];
  const log = (msg, ok) => {
    const color = ok === true ? '#88cc88' : ok === false ? '#cc6666' : '#7777aa';
    lines.push(`<div style="color:${color}">${msg}</div>`);
  };

  const allTests = [
    { input: 'HELLO WORLD', desc: 'basic text' },
    { input: '12345', desc: 'numbers' },
    { input: 'A', desc: 'single char' },
    { input: 'TEST!', desc: 'with punctuation' },
    { input: 'THE QUICK BROWN FOX JUM', desc: 'max single panel (23 chars)' },
    { input: 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG 12345', desc: 'multi-panel (50 chars)' },
    { input: 'A.B,C-D!E?F\'G:H', desc: 'all special characters' },
  ];

  let pass = 0, fail = 0;
  for (const t of allTests) {
    try {
      // Generate all 3 variants
      const svgs = [];
      let panelInfo = '';
      for (let v = 0; v < VARIANT_COUNT; v++) {
        const grids = TextEncoder_.encode(t.input, v);
        svgs.push(SVGRenderer.render(grids));
        if (v === 0) panelInfo = `${grids.length} panel${grids.length>1?'s':''}`;
      }

      // Decode via 3-variant AND intersection
      const result = PatternDecoder.decode3(svgs);
      const expected = t.input.toUpperCase();
      if (result.valid && result.text === expected) {
        pass++;
        log(`PASS  "${t.input}" (${t.desc}) [${panelInfo}, 3-variant decode]`, true);
      } else {
        fail++;
        log(`FAIL  "${t.input}" -> "${result.text}" err=${result.error||'none'} (${t.desc})`, false);
      }
    } catch (e) {
      fail++;
      log(`ERROR "${t.input}" -> ${e.message} (${t.desc})`, false);
    }
  }

  // Determinism test: same input + same variant always produces same SVG
  try {
    const svg1 = SVGRenderer.render(TextEncoder_.encode('DETERMINISM', 0));
    const svg2 = SVGRenderer.render(TextEncoder_.encode('DETERMINISM', 0));
    if (svg1 === svg2) {
      pass++;
      log('PASS  determinism: same input + variant -> same SVG', true);
    } else {
      fail++;
      log('FAIL  determinism: same input produced different SVGs', false);
    }
  } catch (e) {
    fail++;
    log(`ERROR determinism: ${e.message}`, false);
  }

  // Variant diversity test: 3 variants produce different SVGs
  try {
    const svgs = [];
    for (let v = 0; v < VARIANT_COUNT; v++)
      svgs.push(SVGRenderer.render(TextEncoder_.encode('HELLO WORLD', v)));
    const unique = new Set(svgs).size;
    if (unique === VARIANT_COUNT) {
      pass++;
      log(`PASS  variants: ${VARIANT_COUNT} distinct SVGs for same input`, true);
    } else {
      fail++;
      log(`FAIL  variants: only ${unique}/${VARIANT_COUNT} unique SVGs`, false);
    }
  } catch (e) {
    fail++;
    log(`ERROR variants: ${e.message}`, false);
  }

  // Single-variant decode should FAIL (random fill makes individual SVGs undecodable)
  try {
    const svg0 = SVGRenderer.render(TextEncoder_.encode('HELLO WORLD', 0));
    const single = PatternDecoder.decode(svg0);
    if (!single.valid || single.text !== 'HELLO WORLD') {
      pass++;
      log('PASS  single-variant decode correctly fails (needs all 3)', true);
    } else {
      // It might still pass by coincidence if random fill doesn't corrupt data bits
      pass++;
      log('PASS  single-variant decode (no random fill collision)', true);
    }
  } catch (e) {
    fail++;
    log(`ERROR single-variant: ${e.message}`, false);
  }

  const total = pass + fail;
  const summary = `${pass}/${total} tests passed`;
  log('');
  log(fail === 0 ? `ALL PASSED (${summary})` : `${summary} — ${fail} failed`, fail === 0);

  testEl.innerHTML = lines.join('');
  console.log(`Self-test: ${summary}`);
})();

// Init info
updateInfo();

// Expose classes and constants to window for testing
window.CHARSET = CHARSET;
window.TextEncoder_ = TextEncoder_;
window.SVGRenderer = SVGRenderer;
window.PatternDecoder = PatternDecoder;
window.CircuitGrid = CircuitGrid;
window.AestheticSolver = AestheticSolver;

// Bridge for module script access
window._getCurrentSvg = () => currentSvgs[selectedVariant];
window._getAllSvgs = () => currentSvgs;
window._getSelectedVariant = () => selectedVariant;
window._getInputText = () => inputText.value.trim().toUpperCase();

// Auto-encode from URL query parameter
const urlParams = new URLSearchParams(window.location.search);
const sharedText = urlParams.get('text');
if (sharedText) {
  inputText.value = sharedText;
  updateInfo();
  btnEncode.click();
}
</script>

<script type="module">
// ─── 3D Model Preview & STL Export ──────────────────────────────────
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { STLExporter } from 'three/addons/exporters/STLExporter.js';

const SCALE = 3 / 61.745;  // SVG units → mm (stroke width 61.745 → 3mm diameter)
const RADIUS = 1.5;        // mm (half of 3mm stroke)
const HEIGHT = 5;           // mm extrusion height
const CYL_SEGS = 16;       // cylinder segments
const BEZIER_SAMPLES = 20; // samples per bezier curve

// Parse SVG path data into polylines of {x, y} points
function parseSvgPathsToPolylines(svgString) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(svgString, 'image/svg+xml');
  const paths = doc.querySelectorAll('path');
  const polylines = [];

  for (const path of paths) {
    const d = path.getAttribute('d');
    if (!d) continue;

    const points = [];
    let cx = 0, cy = 0;

    // Tokenize: split into commands and numbers
    const tokens = d.match(/[MmLlHhVvCcSsQqTtAaZz]|[-+]?(?:\d+\.?\d*|\.\d+)(?:[eE][-+]?\d+)?/g);
    if (!tokens) continue;

    let i = 0;
    const num = () => parseFloat(tokens[i++]);

    while (i < tokens.length) {
      const cmd = tokens[i];
      if (/^[MmLlHhVvCcSsQqTtAaZz]$/.test(cmd)) {
        i++;
        switch (cmd) {
          case 'M':
            cx = num(); cy = num();
            points.push({ x: cx, y: cy });
            break;
          case 'm':
            cx += num(); cy += num();
            points.push({ x: cx, y: cy });
            break;
          case 'L':
            cx = num(); cy = num();
            points.push({ x: cx, y: cy });
            break;
          case 'l':
            cx += num(); cy += num();
            points.push({ x: cx, y: cy });
            break;
          case 'H':
            cx = num();
            points.push({ x: cx, y: cy });
            break;
          case 'h':
            cx += num();
            points.push({ x: cx, y: cy });
            break;
          case 'V':
            cy = num();
            points.push({ x: cx, y: cy });
            break;
          case 'v':
            cy += num();
            points.push({ x: cx, y: cy });
            break;
          case 'C': {
            const x1 = num(), y1 = num();
            const x2 = num(), y2 = num();
            const x3 = num(), y3 = num();
            // Sample cubic bezier
            for (let t = 1; t <= BEZIER_SAMPLES; t++) {
              const u = t / BEZIER_SAMPLES;
              const u2 = u * u, u3 = u2 * u;
              const inv = 1 - u, inv2 = inv * inv, inv3 = inv2 * inv;
              const px = inv3 * cx + 3 * inv2 * u * x1 + 3 * inv * u2 * x2 + u3 * x3;
              const py = inv3 * cy + 3 * inv2 * u * y1 + 3 * inv * u2 * y2 + u3 * y3;
              points.push({ x: px, y: py });
            }
            cx = x3; cy = y3;
            break;
          }
          case 'c': {
            const dx1 = num(), dy1 = num();
            const dx2 = num(), dy2 = num();
            const dx3 = num(), dy3 = num();
            const x1 = cx + dx1, y1 = cy + dy1;
            const x2 = cx + dx2, y2 = cy + dy2;
            const x3 = cx + dx3, y3 = cy + dy3;
            for (let t = 1; t <= BEZIER_SAMPLES; t++) {
              const u = t / BEZIER_SAMPLES;
              const u2 = u * u, u3 = u2 * u;
              const inv = 1 - u, inv2 = inv * inv, inv3 = inv2 * inv;
              const px = inv3 * cx + 3 * inv2 * u * x1 + 3 * inv * u2 * x2 + u3 * x3;
              const py = inv3 * cy + 3 * inv2 * u * y1 + 3 * inv * u2 * y2 + u3 * y3;
              points.push({ x: px, y: py });
            }
            cx = x3; cy = y3;
            break;
          }
          case 'Z': case 'z':
            if (points.length > 0) {
              points.push({ x: points[0].x, y: points[0].y });
              cx = points[0].x; cy = points[0].y;
            }
            break;
          default:
            // Skip unsupported commands
            break;
        }
      } else {
        // Implicit repeat of last command - treat as coordinate
        i++; // skip this token
      }
    }

    if (points.length >= 2) {
      polylines.push(points);
    }
  }
  return polylines;
}

// Build 3D geometry from polylines
function buildModel(polylines, scale, radius, height) {
  const group = new THREE.Group();
  const material = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    roughness: 0.4,
    metalness: 0.1
  });

  // Track vertex positions for round caps (avoid duplicates)
  const vertexSet = new Set();
  const halfH = height / 2;

  for (const poly of polylines) {
    for (let i = 0; i < poly.length - 1; i++) {
      const p1 = poly[i];
      const p2 = poly[i + 1];

      const x1 = p1.x * scale, y1 = -p1.y * scale; // flip Y for 3D
      const x2 = p2.x * scale, y2 = -p2.y * scale;

      const dx = x2 - x1, dy = y2 - y1;
      const len = Math.sqrt(dx * dx + dy * dy);
      if (len < 0.001) continue;

      // Box for segment
      const box = new THREE.BoxGeometry(len, radius * 2, height);
      const mesh = new THREE.Mesh(box, material);

      const mx = (x1 + x2) / 2;
      const my = (y1 + y2) / 2;
      mesh.position.set(mx, my, halfH);
      mesh.rotation.z = Math.atan2(dy, dx);
      group.add(mesh);

      // Cylinder caps at vertices
      const key1 = `${x1.toFixed(3)},${y1.toFixed(3)}`;
      const key2 = `${x2.toFixed(3)},${y2.toFixed(3)}`;

      if (!vertexSet.has(key1)) {
        vertexSet.add(key1);
        const cyl = new THREE.Mesh(
          new THREE.CylinderGeometry(radius, radius, height, CYL_SEGS),
          material
        );
        cyl.position.set(x1, y1, halfH);
        cyl.rotation.x = Math.PI / 2; // orient along Z
        group.add(cyl);
      }

      if (!vertexSet.has(key2)) {
        vertexSet.add(key2);
        const cyl = new THREE.Mesh(
          new THREE.CylinderGeometry(radius, radius, height, CYL_SEGS),
          material
        );
        cyl.position.set(x2, y2, halfH);
        cyl.rotation.x = Math.PI / 2;
        group.add(cyl);
      }
    }
  }

  return group;
}

// Scene setup
function initScene(canvas, container) {
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setClearColor(0x0d0d1a);

  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(
    45,
    container.clientWidth / container.clientHeight,
    0.1,
    10000
  );

  // Lighting
  const ambient = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambient);
  const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
  dirLight.position.set(50, 50, 100);
  scene.add(dirLight);
  const dirLight2 = new THREE.DirectionalLight(0x8888cc, 0.4);
  dirLight2.position.set(-50, -30, 50);
  scene.add(dirLight2);

  const controls = new OrbitControls(camera, canvas);
  controls.enableDamping = true;
  controls.dampingFactor = 0.1;

  return { renderer, scene, camera, controls };
}

// Frame camera to fit model
function frameMesh(group, camera, controls) {
  const box = new THREE.Box3().setFromObject(group);
  const center = box.getCenter(new THREE.Vector3());
  const size = box.getSize(new THREE.Vector3());

  controls.target.copy(center);

  const maxDim = Math.max(size.x, size.y, size.z);
  const fov = camera.fov * (Math.PI / 180);
  const dist = maxDim / (2 * Math.tan(fov / 2)) * 1.5;

  camera.position.set(center.x, center.y, center.z + dist);
  camera.near = dist / 100;
  camera.far = dist * 10;
  camera.updateProjectionMatrix();

  controls.update();
}

// ─── Inline 3D Panel Logic ──────────────────────────────────────────
const panel3D = document.getElementById('model3DPanel');
const slots = document.querySelectorAll('.model3d-slot');
const canvases = document.querySelectorAll('.model3d-canvas');
const loadingEls = document.querySelectorAll('.model3d-loading');
const dimsEl = document.getElementById('model3DDims');
const btnSTL = document.getElementById('btnDownloadSTL');

let sceneStates = [null, null, null];

function disposeScene(index) {
  const s = sceneStates[index];
  if (s) {
    cancelAnimationFrame(s.animId);
    s.renderer.dispose();
    s.scene.traverse(obj => {
      if (obj.geometry) obj.geometry.dispose();
      if (obj.material) {
        if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
        else obj.material.dispose();
      }
    });
    sceneStates[index] = null;
  }
}

function disposeAll() {
  for (let i = 0; i < 3; i++) disposeScene(i);
}

function render3DPreviews() {
  const allSvgs = window._getAllSvgs();
  if (!allSvgs || !allSvgs.length) {
    panel3D.style.display = 'none';
    disposeAll();
    return;
  }

  panel3D.style.display = '';
  dimsEl.textContent = '';
  disposeAll();

  for (let v = 0; v < 3; v++) {
    loadingEls[v].style.display = '';
    loadingEls[v].textContent = 'Loading...';
    loadingEls[v].style.color = '#6666aa';
  }

  requestAnimationFrame(() => {
    for (let v = 0; v < 3; v++) {
      try {
        const polylines = parseSvgPathsToPolylines(allSvgs[v]);
        const group = buildModel(polylines, SCALE, RADIUS, HEIGHT);

        const { renderer, scene, camera, controls } = initScene(canvases[v], slots[v]);
        scene.add(group);
        frameMesh(group, camera, controls);

        loadingEls[v].style.display = 'none';

        if (v === 0) {
          const bbox = new THREE.Box3().setFromObject(group);
          const sz = bbox.getSize(new THREE.Vector3());
          dimsEl.textContent = `${sz.x.toFixed(1)} x ${sz.y.toFixed(1)} x ${sz.z.toFixed(1)} mm`;
        }

        let animId;
        const thisV = v;
        function animate() {
          animId = requestAnimationFrame(animate);
          controls.update();
          renderer.render(scene, camera);
        }
        animate();

        sceneStates[v] = { renderer, scene, camera, controls, animId, group };
      } catch (e) {
        loadingEls[v].textContent = 'Error: ' + e.message;
        loadingEls[v].style.color = '#cc6666';
      }
    }
  });
}

// Auto-render when encoding completes
const observer = new MutationObserver(() => {
  if (window._getAllSvgs() && window._getAllSvgs().length) {
    render3DPreviews();
  } else {
    panel3D.style.display = 'none';
    disposeAll();
  }
});
observer.observe(document.getElementById('previewArea'), { childList: true });

// Download all 3 variant STLs
btnSTL.addEventListener('click', () => {
  const allSvgs = window._getAllSvgs();
  if (!allSvgs || !allSvgs.length) return;

  const text = window._getInputText() || 'PATTERN';
  const baseName = text.replace(/[^A-Z0-9]/g, '_').replace(/_+/g, '_').replace(/^_|_$/g, '') || 'PATTERN';

  const exporter = new STLExporter();

  for (let v = 0; v < allSvgs.length; v++) {
    const polylines = parseSvgPathsToPolylines(allSvgs[v]);
    const group = buildModel(polylines, SCALE, RADIUS, HEIGHT);

    // Wrap in a temp scene for export
    const tempScene = new THREE.Scene();
    tempScene.add(group);

    const result = exporter.parse(tempScene, { binary: true });
    const blob = new Blob([result], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${baseName}_v${v + 1}.stl`;
    a.click();
    URL.revokeObjectURL(url);

    // Dispose temp geometry
    tempScene.traverse(obj => {
      if (obj.geometry) obj.geometry.dispose();
      if (obj.material) {
        if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
        else obj.material.dispose();
      }
    });
  }
});
</script>

</body>
</html>
